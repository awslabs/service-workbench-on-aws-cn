"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultSidebarItemsGenerator = exports.CategoryMetadataFilenamePattern = exports.CategoryMetadataFilenameBase = void 0;
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const utils_1 = require("@docusaurus/utils");
const utils_validation_1 = require("@docusaurus/utils-validation");
const chalk_1 = (0, tslib_1.__importDefault)(require("chalk"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const fs_extra_1 = (0, tslib_1.__importDefault)(require("fs-extra"));
const js_yaml_1 = (0, tslib_1.__importDefault)(require("js-yaml"));
const BreadcrumbSeparator = '/';
// To avoid possible name clashes with a folder of the same name as the ID
const docIdPrefix = '$doc$/';
exports.CategoryMetadataFilenameBase = '_category_';
exports.CategoryMetadataFilenamePattern = '_category_.{json,yml,yaml}';
const CategoryMetadatasFileSchema = utils_validation_1.Joi.object({
    label: utils_validation_1.Joi.string(),
    position: utils_validation_1.Joi.number(),
    collapsed: utils_validation_1.Joi.boolean(),
    collapsible: utils_validation_1.Joi.boolean(),
    className: utils_validation_1.Joi.string(),
});
// TODO I now believe we should read all the category metadata files ahead of time: we may need this metadata to customize docs metadata
// Example use-case being able to disable number prefix parsing at the folder level, or customize the default route path segment for an intermediate directory...
// TODO later if there is `CategoryFolder/index.md`, we may want to read the metadata as yaml on it
// see https://github.com/facebook/docusaurus/issues/3464#issuecomment-818670449
async function readCategoryMetadatasFile(categoryDirPath) {
    var _a, _b;
    async function tryReadFile(fileNameWithExtension, parse) {
        // Simpler to use only posix paths for mocking file metadatas in tests
        const filePath = (0, utils_1.posixPath)(path_1.default.join(categoryDirPath, fileNameWithExtension));
        if (await fs_extra_1.default.pathExists(filePath)) {
            const contentString = await fs_extra_1.default.readFile(filePath, { encoding: 'utf8' });
            const unsafeContent = parse(contentString);
            try {
                return utils_validation_1.Joi.attempt(unsafeContent, CategoryMetadatasFileSchema);
            }
            catch (e) {
                console.error(chalk_1.default.red(`The docs sidebar category metadata file looks invalid!\nPath: ${filePath}`));
                throw e;
            }
        }
        return null;
    }
    return ((_b = (_a = (await tryReadFile(`${exports.CategoryMetadataFilenameBase}.json`, JSON.parse))) !== null && _a !== void 0 ? _a : (await tryReadFile(`${exports.CategoryMetadataFilenameBase}.yml`, js_yaml_1.default.load))) !== null && _b !== void 0 ? _b : 
    // eslint-disable-next-line no-return-await
    (await tryReadFile(`${exports.CategoryMetadataFilenameBase}.yaml`, js_yaml_1.default.load)));
}
// Comment for this feature: https://github.com/facebook/docusaurus/issues/3464#issuecomment-818670449
const DefaultSidebarItemsGenerator = async ({ numberPrefixParser, docs: allDocs, options, item: { dirName: autogenDir }, version, }) => {
    /**
     * Step 1. Extract the docs that are in the autogen dir.
     */
    function getAutogenDocs() {
        function isInAutogeneratedDir(doc) {
            return (
            // Doc at the root of the autogenerated sidebar dir
            doc.sourceDirName === autogenDir ||
                // autogen dir is . and doc is in subfolder
                autogenDir === '.' ||
                // autogen dir is not . and doc is in subfolder
                // "api/myDoc" startsWith "api/" (note "api2/myDoc" is not included)
                doc.sourceDirName.startsWith((0, utils_1.addTrailingSlash)(autogenDir)));
        }
        const docs = allDocs.filter(isInAutogeneratedDir);
        if (docs.length === 0) {
            console.warn(chalk_1.default.yellow(`No docs found in dir ${autogenDir}: can't auto-generate a sidebar.`));
        }
        return docs;
    }
    /**
     * Step 2. Turn the linear file list into a tree structure.
     */
    function treeify(docs) {
        // Get the category breadcrumb of a doc (relative to the dir of the autogenerated sidebar item)
        // autogenDir=a/b and docDir=a/b/c/d => returns [c, d]
        // autogenDir=a/b and docDir=a/b => returns []
        // TODO: try to use path.relative()
        function getRelativeBreadcrumb(doc) {
            return autogenDir === doc.sourceDirName
                ? []
                : doc.sourceDirName
                    .replace((0, utils_1.addTrailingSlash)(autogenDir), '')
                    .split(BreadcrumbSeparator);
        }
        const treeRoot = {};
        docs.forEach((doc) => {
            const breadcrumb = getRelativeBreadcrumb(doc);
            let currentDir = treeRoot; // We walk down the file's path to generate the fs structure
            // eslint-disable-next-line no-restricted-syntax
            for (const dir of breadcrumb) {
                if (typeof currentDir[dir] === 'undefined') {
                    currentDir[dir] = {}; // Create new folder.
                }
                currentDir = currentDir[dir]; // Go into the subdirectory.
            }
            currentDir[`${docIdPrefix}${doc.id}`] = null; // We've walked through the file path. Register the file in this directory.
        });
        return treeRoot;
    }
    /**
     * Step 3. Recursively transform the tree-like file structure to sidebar items.
     * (From a record to an array of items, akin to normalizing shorthand)
     */
    function generateSidebar(fsModel) {
        const docsById = (0, lodash_1.keyBy)(allDocs, (doc) => doc.id);
        function createDocItem(id) {
            const { sidebarPosition: position, frontMatter: { sidebar_label: label, sidebar_class_name: className }, } = docsById[id];
            return {
                type: 'doc',
                id,
                position,
                // We don't want these fields to magically appear in the generated sidebar
                ...(label !== undefined && { label }),
                ...(className !== undefined && { className }),
            };
        }
        async function createCategoryItem(dir, fullPath, folderName) {
            var _a, _b, _c, _d;
            const categoryPath = path_1.default.join(version.contentPath, autogenDir, fullPath);
            const categoryMetadatas = await readCategoryMetadatasFile(categoryPath);
            const className = categoryMetadatas === null || categoryMetadatas === void 0 ? void 0 : categoryMetadatas.className;
            const { filename, numberPrefix } = numberPrefixParser(folderName);
            return {
                type: 'category',
                label: (_a = categoryMetadatas === null || categoryMetadatas === void 0 ? void 0 : categoryMetadatas.label) !== null && _a !== void 0 ? _a : filename,
                collapsible: (_b = categoryMetadatas === null || categoryMetadatas === void 0 ? void 0 : categoryMetadatas.collapsible) !== null && _b !== void 0 ? _b : options.sidebarCollapsible,
                collapsed: (_c = categoryMetadatas === null || categoryMetadatas === void 0 ? void 0 : categoryMetadatas.collapsed) !== null && _c !== void 0 ? _c : options.sidebarCollapsed,
                position: (_d = categoryMetadatas === null || categoryMetadatas === void 0 ? void 0 : categoryMetadatas.position) !== null && _d !== void 0 ? _d : numberPrefix,
                ...(className !== undefined && { className }),
                items: await Promise.all(Object.entries(dir).map(([key, content]) => dirToItem(content, key, `${fullPath}/${key}`))),
            };
        }
        async function dirToItem(dir, // The directory item to be transformed.
        itemKey, // For docs, it's the doc ID; for categories, it's used to generate the next `relativePath`.
        fullPath) {
            return dir
                ? createCategoryItem(dir, fullPath, itemKey)
                : createDocItem(itemKey.substring(docIdPrefix.length));
        }
        return Promise.all(Object.entries(fsModel).map(([key, content]) => dirToItem(content, key, key)));
    }
    /**
     * Step 4. Recursively sort the categories/docs + remove the "position" attribute from final output.
     * Note: the "position" is only used to sort "inside" a sidebar slice. It is not
     * used to sort across multiple consecutive sidebar slices (ie a whole Category
     * composed of multiple autogenerated items)
     */
    function sortItems(sidebarItems) {
        const processedSidebarItems = sidebarItems.map((item) => {
            if (item.type === 'category') {
                return { ...item, items: sortItems(item.items) };
            }
            return item;
        });
        const sortedSidebarItems = (0, lodash_1.sortBy)(processedSidebarItems, (item) => item.position);
        return sortedSidebarItems.map(({ position, ...item }) => item);
    }
    // TODO: the whole code is designed for pipeline operator
    // return getAutogenDocs() |> treeify |> await generateSidebar(^) |> sortItems;
    const docs = getAutogenDocs();
    const fsModel = treeify(docs);
    const sidebarWithPosition = await generateSidebar(fsModel);
    const sortedSidebar = sortItems(sidebarWithPosition);
    return sortedSidebar;
};
exports.DefaultSidebarItemsGenerator = DefaultSidebarItemsGenerator;
