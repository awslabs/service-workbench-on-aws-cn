"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.processSidebars = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("./utils");
const generator_1 = require("./generator");
const lodash_1 = require("lodash");
const combine_promises_1 = (0, tslib_1.__importDefault)(require("combine-promises"));
function toSidebarItemsGeneratorDoc(doc) {
    return (0, lodash_1.pick)(doc, [
        'id',
        'frontMatter',
        'source',
        'sourceDirName',
        'sidebarPosition',
    ]);
}
function toSidebarItemsGeneratorVersion(version) {
    return (0, lodash_1.pick)(version, ['versionName', 'contentPath']);
}
// Handle the generation of autogenerated sidebar items and other post-processing checks
async function processSidebar(unprocessedSidebar, { sidebarItemsGenerator, numberPrefixParser, docs, version, options, }) {
    // Just a minor lazy transformation optimization
    const getSidebarItemsGeneratorDocsAndVersion = (0, lodash_1.memoize)(() => ({
        docs: docs.map(toSidebarItemsGeneratorDoc),
        version: toSidebarItemsGeneratorVersion(version),
    }));
    async function handleAutoGeneratedItems(item) {
        if (item.type === 'category') {
            return [
                {
                    ...item,
                    items: (await Promise.all(item.items.map(handleAutoGeneratedItems))).flat(),
                },
            ];
        }
        if (item.type === 'autogenerated') {
            return sidebarItemsGenerator({
                item,
                numberPrefixParser,
                defaultSidebarItemsGenerator: generator_1.DefaultSidebarItemsGenerator,
                ...getSidebarItemsGeneratorDocsAndVersion(),
                options,
            });
        }
        return [item];
    }
    const processedSidebar = (await Promise.all(unprocessedSidebar.map(handleAutoGeneratedItems))).flat();
    const fixSidebarItemInconsistencies = (item) => {
        // A non-collapsible category can't be collapsed!
        if (item.type === 'category' && !item.collapsible && item.collapsed) {
            return {
                ...item,
                collapsed: false,
            };
        }
        return item;
    };
    return (0, utils_1.transformSidebarItems)(processedSidebar, fixSidebarItemInconsistencies);
}
async function processSidebars(unprocessedSidebars, props) {
    return (0, combine_promises_1.default)((0, lodash_1.mapValues)(unprocessedSidebars, (unprocessedSidebar) => processSidebar(unprocessedSidebar, props)));
}
exports.processSidebars = processSidebars;
