"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSidebarsUtils = exports.collectSidebarsDocIds = exports.collectSidebarLinks = exports.collectSidebarCategories = exports.collectSidebarDocItems = exports.transformSidebarItems = void 0;
const lodash_1 = require("lodash");
const utils_1 = require("@docusaurus/utils");
function transformSidebarItems(sidebar, updateFn) {
    function transformRecursive(item) {
        if (item.type === 'category') {
            return updateFn({
                ...item,
                items: item.items.map(transformRecursive),
            });
        }
        return updateFn(item);
    }
    return sidebar.map(transformRecursive);
}
exports.transformSidebarItems = transformSidebarItems;
function collectSidebarItemsOfType(type, sidebar) {
    function collectRecursive(item) {
        const currentItemsCollected = item.type === type ? [item] : [];
        const childItemsCollected = item.type === 'category' ? item.items.flatMap(collectRecursive) : [];
        return [...currentItemsCollected, ...childItemsCollected];
    }
    return sidebar.flatMap(collectRecursive);
}
function collectSidebarDocItems(sidebar) {
    return collectSidebarItemsOfType('doc', sidebar);
}
exports.collectSidebarDocItems = collectSidebarDocItems;
function collectSidebarCategories(sidebar) {
    return collectSidebarItemsOfType('category', sidebar);
}
exports.collectSidebarCategories = collectSidebarCategories;
function collectSidebarLinks(sidebar) {
    return collectSidebarItemsOfType('link', sidebar);
}
exports.collectSidebarLinks = collectSidebarLinks;
function collectSidebarsDocIds(sidebars) {
    return (0, lodash_1.mapValues)(sidebars, (sidebar) => {
        return collectSidebarDocItems(sidebar).map((docItem) => docItem.id);
    });
}
exports.collectSidebarsDocIds = collectSidebarsDocIds;
function createSidebarsUtils(sidebars) {
    const sidebarNameToDocIds = collectSidebarsDocIds(sidebars);
    // Reverse mapping
    const docIdToSidebarName = Object.fromEntries(Object.entries(sidebarNameToDocIds).flatMap(([sidebarName, docIds]) => docIds.map((docId) => [docId, sidebarName])));
    function getFirstDocIdOfFirstSidebar() {
        var _a;
        return (_a = Object.values(sidebarNameToDocIds)[0]) === null || _a === void 0 ? void 0 : _a[0];
    }
    function getSidebarNameByDocId(docId) {
        return docIdToSidebarName[docId];
    }
    function getDocNavigation(docId) {
        const sidebarName = getSidebarNameByDocId(docId);
        if (sidebarName) {
            const docIds = sidebarNameToDocIds[sidebarName];
            const currentIndex = docIds.indexOf(docId);
            const { previous, next } = (0, utils_1.getElementsAround)(docIds, currentIndex);
            return {
                sidebarName,
                previousId: previous,
                nextId: next,
            };
        }
        else {
            return {
                sidebarName: undefined,
                previousId: undefined,
                nextId: undefined,
            };
        }
    }
    function checkSidebarsDocIds(validDocIds, sidebarFilePath) {
        const allSidebarDocIds = Object.values(sidebarNameToDocIds).flat();
        const invalidSidebarDocIds = (0, lodash_1.difference)(allSidebarDocIds, validDocIds);
        if (invalidSidebarDocIds.length > 0) {
            throw new Error(`Invalid sidebar file at "${(0, utils_1.toMessageRelativeFilePath)(sidebarFilePath)}".
These sidebar document ids do not exist:
- ${invalidSidebarDocIds.sort().join('\n- ')}

Available document ids are:
- ${validDocIds.sort().join('\n- ')}`);
        }
    }
    return {
        getFirstDocIdOfFirstSidebar,
        getSidebarNameByDocId,
        getDocNavigation,
        checkSidebarsDocIds,
    };
}
exports.createSidebarsUtils = createSidebarsUtils;
